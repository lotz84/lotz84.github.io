<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Haskellを書いてるプログラマーはザコなのか</title>
        <meta name="viewport" content="width=device-width" />
        <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Lora" />
        <link rel="stylesheet" href="../css/kube.min.css" />
        <link rel="stylesheet" href="../css/prism.css" />
        <link rel="stylesheet" href="../css/main.css" />
        <link rel="stylesheet" href="../font/octicons.css" />
        <script type="text/javascript" src="../js/prism.js"></script>
    </head>
    <body>
        <div class="units-row units-padding">
            <div class="unit-20 sidemenu">
                <h1><a href="../">flip map <img src="../img/samurai.png" style="margin:-15px 0 0 -30px;width:60px"></a></h1>
                <p><a href="https://placekitten.com/"><img src="https://placekitten.com/g/200/160"></a></p>
                <h2>Index</h2>
                <ul>
                    <li><a href="../about"><span class="octicon octicon-person"></span> About</a></li>
                    <li><a href="../posts"><span class="octicon octicon-file-text"></span> Blog</a></li>
                    <li><a href="https://github.com/lotz84" target="blank_"><span class="octicon octicon-mark-github"></span> Github</a></li>
                    <li><a href="https://twitter.com/lotz84_" target="blank_"><span class="octicon octicon-mention"></span> Twitter</a></li>
                    <li><a href="../feed.xml" target="blank_"><span class="octicon octicon-rss"></span> RSS</a></li>
                </ul>
            </div>
            <div class="unit-80">
                <h1>Haskellを書いてるプログラマーはザコなのか</h1>
<p>2015/04/13</p>
<p><strong>tl;dr</strong><br />
そんなわけないからJavaと比較して検討してみた。</p>
<p>自分のツイートがプチ炎上しました</p>
<p><a href="https://twitter.com/lotz84_/status/586785908105416704"><img src="http://i.gyazo.com/04de63d6dfce54b05f05c8d0d575f1e3.png" alt /></a></p>
<p>関数型界隈はただでさえコミュニティが尖ってて怖いとか言われるのに自分もその端くれながら攻撃的な発言をしてしまって申し訳なく思っています。弁明も兼ねてnullが無くても再代入ができ無くても社会で通用するコードを量産しているJavaと負けず劣らないコードが書けることを具体例を上げて説明したいと思います。</p>
<h2 id="再代入できない">再代入できない</h2>
<p>Haskellは変数への再代入ができません。どういうことかというと一度値を代入した値に別の値を入れることが不可能なのです。例えばJavaでは</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">class</span> Main {
    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(String[] args) {
        <span class="dt">int</span> x = <span class="dv">0</span>;
        x = <span class="dv">1</span>;

        System.<span class="fu">out</span>.<span class="fu">println</span>(x);
    }
}</code></pre></div>
<p>この様に一度宣言した変数xに何回も値を代入することができます。しかしHaskellでは</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">x <span class="fu">=</span> <span class="dv">0</span>
x <span class="fu">=</span> <span class="dv">1</span>

main <span class="fu">=</span> print x</code></pre></div>
<p>なんて書くと<code>Multiple declarations of ‘x’</code>と言ってコンパイラに怒られます。</p>
<p>だったら再代入が絶対に必要そうな処理はどうかくのか、例えば配列の中身を全部足し合わせる処理は合計を保存するような変数を用意して<code>for</code>文でリストの中身を回して足し合わせなければいけないような気がします。Javaで書くと</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">class</span> Main {
    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(String[] args) {
        <span class="dt">int</span>[] array = {<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>};
        <span class="dt">int</span> total = <span class="dv">0</span>;
        <span class="kw">for</span> (<span class="dt">int</span> i : array) {
            total += i;
        }

        System.<span class="fu">out</span>.<span class="fu">println</span>(total);
    }
}</code></pre></div>
<p>こう書けます。ではHaskellで同じような処理を書くとどうなるでしょう。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">array <span class="fu">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]
total <span class="fu">=</span> sum array

main <span class="fu">=</span> print total</code></pre></div>
<p>こうなります。ですがちょっと待って下さい、今回は<code>sum</code>という<strong>リストの中身を全部足し合わせる</strong>関数がたまたまあっただけかもしれません。しかし<code>sum</code>を更に詳しく見ていけば再代入が不要になるトリックが見えてきます。<code>sum</code>の定義は</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">sum <span class="fu">=</span> foldl (<span class="fu">+</span>) <span class="dv">0</span></code></pre></div>
<p>となっています。<code>foldl</code>という新しい関数が出てきました。この関数の定義は</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldl<span class="ot"> ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b
foldl f z []     <span class="fu">=</span>  z
foldl f z (x<span class="fu">:</span>xs) <span class="fu">=</span>  foldl f (f z x) xs</code></pre></div>
<p>となります。目を回すかもしれませんが具体的な値を入れてその動作を見て行きましょう。 さっきの例の場合は結局</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldl (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]</code></pre></div>
<p>を計算することになります。これを<code>foldl</code>の定義を照らしあわせて評価していくと</p>
<pre class="markup"><code>foldl (+) 0 [1, 2, 3, 4, 5]
foldl (+) 0 (1 : [2, 3, 4, 5])
foldl (+) (0 + 1) [2, 3, 4, 5]
foldl (+) (0 + 1) (2 : [3, 4, 5])
foldl (+) ((0 + 1) + 2) [3, 4, 5]
foldl (+) ((0 + 1) + 2) (3 : [4, 5])
foldl (+) (((0 + 1) + 2) + 3) [4, 5]
foldl (+) (((0 + 1) + 2) + 3) (4 : [5])
foldl (+) ((((0 + 1) + 2) + 3) + 4) [5]
foldl (+) ((((0 + 1) + 2) + 3) + 4) (5 : [])
foldl (+) (((((0 + 1) + 2) + 3) + 4) + 5) []
((((0 + 1) + 2) + 3) + 4) + 5
1 + 2 + 3 + 4 + 5</code></pre>
<p><code>foldl</code>という関数がリストの値を1つづつ足していく関数を巧みに組み立てていくのがおわかりいただけたでしょうか。Haskellがやっていたのは変数に値を足していくことではなく、<strong>関数で関数を組み上げていくこと</strong>だったのです。同じ方法を用いて“文字列を全て足し合わせる処理”とか“リストの中の最大値を求める処理”を書くこともできます。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">strs <span class="fu">=</span> [<span class="st">&quot;apple&quot;</span>, <span class="st">&quot;orange&quot;</span>, <span class="st">&quot;grape&quot;</span>]
coupled <span class="fu">=</span> foldl (<span class="fu">++</span>) <span class="st">&quot;&quot;</span> strs

main <span class="fu">=</span> putStrLn coupled
<span class="co">-- appleorangegrape</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">nums <span class="fu">=</span> [<span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">9</span>, <span class="dv">2</span>]
highest <span class="fu">=</span> foldl max <span class="dv">0</span> nums

main <span class="fu">=</span> print highest
<span class="co">-- 9</span></code></pre></div>
<p>累積用の変数も一時保存用の変数も必要ありません。</p>
<p>もちろんこんな単純な例だけで再代入を使わずに全てのプログラムが書けることを証明したわけではありません。ですが再代入を使えなくても案外いろんな処理を書けるものだと思ってもらえれば幸いです。</p>
<h2 id="nullが無い">nullが無い</h2>
<p>最近になってJavaにもOptionalが導入されましたが既存ライブラリがすぐに対応するわけでもなく今でもJavaはnullの温床になっています。nullをなんでこんなに悪く言うのかというと10億ドルの過ちだからとか別にそういうのはどうでもよくて単にこいつのせいで何度もコードが落ちて大変な目にあったからです。個人的な恨みです。</p>
<p>具体例から見て行きましょう。名前と成績が組になったデータ構造を考えてその配列から特定の成績をとった人の名前を調べたいとします。Javaの場合は成績と配列を渡せば目的の値を返すか、もし見つからなければnullを返すような関数を書けばいいでしょう。</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">class</span> Result {
    <span class="kw">private</span> String name;
    <span class="kw">private</span> Integer score;

    Result (String name, Integer score) {
        <span class="kw">this</span>.<span class="fu">name</span> = name;
        <span class="kw">this</span>.<span class="fu">score</span> = score;
    }

    <span class="kw">public</span> String <span class="fu">getName</span>() {
        <span class="kw">return</span> name;
    }

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">setName</span>(String name) {
        <span class="kw">this</span>.<span class="fu">name</span> = name;
    }

    <span class="kw">public</span> Integer <span class="fu">getScore</span>() {
        <span class="kw">return</span> score;
    }

    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">setScore</span>(Integer score) {
        <span class="kw">this</span>.<span class="fu">score</span> = score;
    }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">class</span> Main {
    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(String[] args) {
        Result array[] = <span class="kw">new</span> Result[<span class="dv">5</span>];
        array[<span class="dv">0</span>] = <span class="kw">new</span> Result(<span class="st">&quot;藤原&quot;</span>, <span class="dv">80</span>);
        array[<span class="dv">1</span>] = <span class="kw">new</span> Result(<span class="st">&quot;水橋&quot;</span>, <span class="dv">65</span>);
        array[<span class="dv">2</span>] = <span class="kw">new</span> Result(<span class="st">&quot;伊吹&quot;</span>, <span class="dv">20</span>);
        array[<span class="dv">3</span>] = <span class="kw">new</span> Result(<span class="st">&quot;八雲&quot;</span>, <span class="dv">100</span>);
        array[<span class="dv">4</span>] = <span class="kw">new</span> Result(<span class="st">&quot;散野&quot;</span>, <span class="dv">0</span>);

        Result target = <span class="fu">search</span>(<span class="dv">100</span>, array);
        <span class="kw">if</span> (target == <span class="kw">null</span>) {
            System.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;満点はいませんでした&quot;</span>);
        } <span class="kw">else</span> {
            System.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;満点は&quot;</span> + target.<span class="fu">getName</span>() + <span class="st">&quot;です&quot;</span>);
        }
    }

    <span class="kw">public</span> <span class="dt">static</span> Result <span class="fu">search</span>(Integer score, Result[] array) {
        <span class="kw">if</span> (score == <span class="kw">null</span>) {
            <span class="kw">return</span> <span class="kw">null</span>;
        }
        <span class="kw">for</span> (Result target : array) {
            <span class="kw">if</span> (target.<span class="fu">getScore</span>() != <span class="kw">null</span> &amp;&amp; target.<span class="fu">getScore</span>().<span class="fu">intValue</span>() == score.<span class="fu">intValue</span>()) {
                <span class="kw">return</span> target;
            }
        }
        <span class="kw">return</span> <span class="kw">null</span>;
    }
}</code></pre></div>
<p>ではHaskellだとどう書けるでしょうか。もし目的の値が見つからなかった時に何を返せばいいでしょうか。Haskellはこういう場合、すなわち関数が返すべき値が無いような場合が存在する時、関数の返り値をMaybe型に包んで返すということをします。Maybe型とは</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="fu">=</span> <span class="dt">Nothing</span> <span class="fu">|</span> <span class="dt">Just</span> a</code></pre></div>
<p>と定義される型でその値は<code>Nothing (何も無い値)</code>か<code>Just a (存在してその値はa)</code>の二種類があります。早速ですが例を見て行きましょう。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.List</span>

<span class="kw">data</span> <span class="dt">Result</span> <span class="fu">=</span> <span class="dt">Result</span> {<span class="ot"> name ::</span> <span class="dt">String</span>
                     ,<span class="ot"> score ::</span> <span class="dt">Int</span>
                     }

array <span class="fu">=</span> [ <span class="dt">Result</span> {name<span class="fu">=</span><span class="st">&quot;藤原&quot;</span>, score<span class="fu">=</span><span class="dv">80</span>}
        , <span class="dt">Result</span> {name<span class="fu">=</span><span class="st">&quot;水橋&quot;</span>, score<span class="fu">=</span><span class="dv">65</span>}
        , <span class="dt">Result</span> {name<span class="fu">=</span><span class="st">&quot;伊吹&quot;</span>, score<span class="fu">=</span><span class="dv">20</span>}
        , <span class="dt">Result</span> {name<span class="fu">=</span><span class="st">&quot;八雲&quot;</span>, score<span class="fu">=</span><span class="dv">100</span>}
        , <span class="dt">Result</span> {name<span class="fu">=</span><span class="st">&quot;散野&quot;</span>, score<span class="fu">=</span><span class="dv">0</span>}
        ]

main <span class="fu">=</span> <span class="kw">do</span>
    <span class="kw">let</span> target <span class="fu">=</span> find (\r <span class="ot">-&gt;</span> score r <span class="fu">==</span> <span class="dv">100</span>) array
    <span class="kw">case</span> target <span class="kw">of</span>
        <span class="dt">Just</span> r  <span class="ot">-&gt;</span> putStrLn <span class="fu">$</span> <span class="st">&quot;満点は&quot;</span> <span class="fu">++</span> name r <span class="fu">++</span> <span class="st">&quot;です&quot;</span>
        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> putStrLn <span class="st">&quot;満点はいませんでした&quot;</span></code></pre></div>
<p>先ほどのJavaと同等なプログラムです。ポイントはtargetの型が単なる<code>Result</code>ではなく<code>Maybe Result</code>であるというところです。そのため<code>name</code>や<code>score</code>といった関数を直接使うことが<strong>できず</strong>、case文を用いて処理を分岐してやる必要があります。もし<code>name target</code>なんて書いた日にはコンパイラに怒られます。厳しいですがこれが愛なのです。</p>
<p>簡単な例でしたがHaskellではnullのような概念を使わずにMaybe型でうまくやっているというのがわかってもらえたでしょうか。</p>
<h2 id="まとめ">まとめ</h2>
<p>Haskellにはnullが無いし再代入できる変数もありません。だからといって使えない言語でもありません。簡単な例でしたがJavaと同等で負けず劣らないコードを書けることを見てきました。ツイートはプチ炎上しましたが多くの人がHaskellを知るきっかけになってもらえれば幸いです。最後に僕が言うまでもなくHaskellは多くの企業で採用され実際に使われている言語です。あとこの手の話が好きならこっちの記事もオススメです👉<a href="http://postd.cc/are-haskell-engineers-second-rate/">【翻訳】Haskellのエンジニアは二流なのか？　（答えはノーである）</a></p>
<div>
    <a href="http://b.hatena.ne.jp/entry/" data-hatena-bookmark-layout="simple-balloon" title="このエントリーをはてなブックマークに追加" class="hatena-bookmark-button"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;"></a><script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
    <a href="https://twitter.com/share" class="twitter-share-button">Tweet</a><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
    <div id="fb-root"></div>
    <script>(function(d, s, id) {
        var js, fjs = d.getElementsByTagName(s)[0];
        if (d.getElementById(id)) return;
            js = d.createElement(s); js.id = id;
            js.src = "//connect.facebook.net/ja_JP/sdk.js#xfbml=1&version=v2.3";
            fjs.parentNode.insertBefore(js, fjs);
        }(document, 'script', 'facebook-jssdk'));
    </script><div data-layout="button_count" data-action="like" data-show-faces="false" data-share="false" class="fb-like"></div>
</div>

            </div>
        </div>
        <script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-38246049-16', 'auto');
            ga('send', 'pageview');
        </script>
    </body>
</html>
